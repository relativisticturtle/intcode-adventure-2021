//---------------------------------------------------
//
//  divmod(*res, a, b)
//
//    res[0]: a / b (integer division)
//    res[1]: a % b (modulus)
//
//---------------------------------------------------

int _xp2[60] = {1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104, 8796093022208, 17592186044416, 35184372088832, 70368744177664, 140737488355328, 281474976710656, 562949953421312, 1125899906842624, 2251799813685248, 4503599627370496, 9007199254740992, 18014398509481984, 36028797018963968, 72057594037927936, 144115188075855872, 288230376151711744, 576460752303423488};

void divmod(int res, int a, int b) {
    res[0] = 0;
    int p;
    // Guard against overflow:
    //   make sure b*_xp2[p] (see next loop) is < 2^59
    //   --> b < _xp2[59 - p]
    for(p=59; (p>=0)*(b > _xp2[59 - p]); p-=1) {
    }
    // Now it should be safe to multiply b and _xp2[p]
    for(; p>=0; p-=1) {
        if(b*_xp2[p] <= a) {
            res[0] += _xp2[p];
            a -= b*_xp2[p];
        }
    }
    res[1] = a;
}
