---
day: 6
prev: day05
this: day06
next: day07
title: Day 6
puzzle: Lanternfish
---
# {{ page.title }}

## [{{ page.puzzle }}](https://adventofcode.com/2021/day/{{ page.day }})

You are worried about `I2C2`.

*&#9835; 376194 lanternfishes in the sea, 376194 lanternfishes. &#9835;*

The IntCode-machine hasn't been itself since the crash yesterday.

*&#9835; Take some down and pass'em around, 395985 lanternfishes in the sea! &#9835;*

You have been meaning to track down the bug (*Please don't let it be one of the [Erisian](https://adventofcode.com/2019/day/24)!*), but other things have come in between, like practicing your [space card shuffling technique](https://adventofcode.com/2019/day/22), and stuff...

*&#9835; 477888 lanternfishes in the sea, 477888 lanternfishes. &#9835;*

Maybe you should spare some time to help your friend.

*&#9835; Take some down and pass'em around, 527548 lanternfishes in the sea! &#9835;*


## Solution

Creative problem. Maintaining a list of lanternfishes would have been tricky (and I had a good suspicion of how the problem would expand for part 2), so I implemented the memory-efficient solution directly in part 1.

**IntCode:** [{{ page.this }}.txt](2021/{{ page.this }}.txt) &#124; **C lite:** [{{ page.this }}.c](2021/{{ page.this }}.c)
{% capture RAW_INTCODE %}{% include_relative 2021/{{ page.this }}.txt %}{% endcapture %}

```
{{RAW_INTCODE}}
```

&nbsp;

# Reflections on the hand-coding

## Regarding the assembly-language...

The IntCode I wrote here was generated in a 100% manual process. Yes, I *did* introduce a assembly-language'ish set of instructions to aid this process, but I have no accompanying assembler. The only automation I used was "search & replace" (`Ctrl-H`) in the second assembly-pass.

Still, even without any assembler-tool it was a *huge* improvement to code with assembly instructions rather than trying to type the numbers directly. It makes the code so much more verbose and easy to follow.

## Regarding my *actual* Day 1 solution...

I'll be frank and confess: I did *not* solve the Day 1's puzzle with the [awesomely coded IntCode-program](2021/day01_manually.txt) we constructed over the last 3 days. The [IntCode-program that I *did* use](2021/day01.txt) was generated by my compiler-tool. How does that program compare to the one we coded now? Let's make a comparison:

| IntCode-program       | Hand-coded | Generated |
| --------------------- | ---------- | --------- |
| Size (integers)       | 60         | 31989     |
| Instructions executed | 3060       | 1735747   |

Whoa! The hand-coded program beats the compiler-generated program by a factor 50&#215;! 

Ok, the comparison is a little unfair. We did after all restrict the hand-coding to "*non-ASCII mode*" for easier input/output-processing, whereas the generated code does full ASCII-processing. For the puzzle input at hand this is quite overkill and cause the program to explode in size.

For a fair comparison I made a few tweaks to the code to make it operate in non-ASCII mode. [That program](day01_nonascii.txt) is 612 integers in size and executes 239249 instructions from start to end. That *is* better. Still a factor &#126;10&#215; from the hand-coded though.

## The benefit of compiler-generated code

To see the benefit of compiler-generated code, let's add another row in this next table:

| IntCode-program       | Hand-coded | Generated | Generated (non-ASCII) |
| --------------------- | ---------- | --------- | --------------------- |
| Size (integers)       | 60         | 31989     | 612                   |
| Instructions executed | 3060       | 1735747   | 239249                |
| Time spend coding     | 2-3 h      | 5 min     | 5 min                 |

My laptop is reasonably fast. Running 1M IntCode-instructions is made in milliseconds. No problem at all. My memory and hard drive both have a few GB's to spare. The program size negligible.

What is not negligible is the *time* I spend coding. Having a compiler tool for a real language (not assembly) I can harness the power of control structures, function calls, and code reuse - without having to worry about the nitty-gritty details of memory allocation, jump-locations, and how everything is carried out by obscure integer operations.

The reason the hand-coding was feasible for the chosen puzzle was that it was so simple. More complex problem become exponentially more diffucult to implement with this approach. It doesn't scale well at all. A problem that would take 15 min to solve with "generated IntCode" may very well take days to solve if done manually.